beauty_of_programming
=======================================================================================================================
1，
=======================================================================================================================






2,
=======================================================================================================================








3,一堆烙饼的排序
=======================================================================================================================
当烙饼不多的时候，我们可以很快的找出最优的翻转方案就是程序中的上界(UpperBound)，也就是说我们感兴趣的最优方案最少
也就是上面方案，那如何能找到更好的优化方案？
程序当中有个剪枝部分：
nEstimate=lowerBound(m_ReverseCakeArray,m_n)
if(step+nEstimate>m_nMaxSwap)
			return;
当m_nMaxSwap越小，剪枝条件就越容易满足,更多的情况就不用去搜索
分析：当nEstimate越大，剪枝条件就越容易满足，也就是说nEstimate越大，nMaxSwap越小，满足的条件就越小，就越容易找到最优化
解，所以在程序中必须体现尽可能减少UpperBound，增加LowerBound，从而减少要搜索的空间。
程序的上界为2*(n-1)，那么程序的下届如何估计呢：
每一次翻转，我们最多使得一个烙饼与大小相邻的烙饼排到一起。如果当前n个烙饼中，有m对相邻的烙饼半径不想了，那么我们至少需
要m次才能排好序。程序中通过遍历相邻的两个烙饼，尺寸上是否相邻来进行最小界的估计

4,买书问题（如何买书最便宜，连续买几本不同的折扣高）
=======================================================================================================================
利用动态规划解决问题，多条件递归进程处理，最后比较哪种方式的价格最低
这里把买书问题看作一个动态规划问题，状态转移方程为：
F(Y1,Y2,Y3,Y4.Y5)=0  if(Y1=Y2=Y3=Y4=Y5=0)
or F(Y1,Y2,Y3,Y4,Y5)=min{5*8*(1-25%)+F(Y1-1,Y2-1,Y3-1,Y4-1,Y5-1),
 4*8*(1-20%)+F(Y1-1,Y2-1,Y3-1,Y4-1,Y5),
 3*8*(1-10%)+F(Y1-1,Y2-1,Y3-1,Y4,Y5),
 2*8*(1-5%)+F(Y1-1,Y2-1,Y3,Y4,Y5),
 8+F(Y1-1,Y2,Y3,Y4,Y5)}





5，快速找出机器故障（找出双备份记录中仅出现一次的某个数）
=======================================================================================================================
算法核心原理：一个数和其本身的异或为0，具体情况见代码包括丢失两个记录（两个相同与两个不同）
这次代码中注释很详细，忘了的话可以看看代码


6，饮料供货（代码来自CSDN某博友ps：他的代码有点小错误）
=======================================================================================================================
在饮料总量限定的情况下，如何找到总满意度最大的一种选择，如果能列出推导公式，那么利用动态规划将很轻松就能解决







7，光影切割问题
=======================================================================================================================
光影切割部分问题能够够根据直线条数和交点数目改变成为更具比较简单的问题：
如果有N条直线，其中有M个交点，那么分块区域的数目为N+M+1
故我们只需要求N条直线M个焦点的情况，根据《编程之美》P51中图1-13所示，交点的个数就转换成了如何求一个N个元素的数组的逆序数
求逆序数时间复杂度较低的算法是采用分冶的思想，首先求N/2个元素的逆序数然后求后N/2个逆序数，最后在排序过程中合并前后两部分
的逆序数。
逆序数的求法参见这篇博文：http://blog.csdn.net/dlengong/article/details/7594919



8，电梯调度算法
=======================================================================================================================
电梯每次载满乘客后只在某一层停留，剩余的需要自己走楼梯，如何保证走楼梯的总数目最小
分析：假设有N1个乘客在i层以下，N2个乘客在i层，N3个层客在i层以上，那么假如我选择在i-1层停，那么比i层停多走的层数为N2+N3-N1
如果选择在i+1层停，那么比i层夺走的层数为N1+N2-N3。比较两者多走的大小，易知何时选择上升合适，何时选择下降合适。
代码可以从这方面着手，我们从第一层开始，得到某层以上的人数，某层所在人数，某层以上人数然后通过上述所述策略来判断是否上升
直到第一次不再上升即找到了合适的层数来保证所有人数走的层数最少。