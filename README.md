beauty_of_programming
=======================================================================================================================
1，
=======================================================================================================================






2,
=======================================================================================================================








3,一堆烙饼的排序
=======================================================================================================================
当烙饼不多的时候，我们可以很快的找出最优的翻转方案就是程序中的上界(UpperBound)，也就是说我们感兴趣的最优方案最少
也就是上面方案，那如何能找到更好的优化方案？
程序当中有个剪枝部分：
nEstimate=lowerBound(m_ReverseCakeArray,m_n)
if(step+nEstimate>m_nMaxSwap)
			return;
当m_nMaxSwap越小，剪枝条件就越容易满足,更多的情况就不用去搜索
分析：当nEstimate越大，剪枝条件就越容易满足，也就是说nEstimate越大，nMaxSwap越小，满足的条件就越小，就越容易找到最优化
解，所以在程序中必须体现尽可能减少UpperBound，增加LowerBound，从而减少要搜索的空间。
程序的上界为2*(n-1)，那么程序的下届如何估计呢：
每一次翻转，我们最多使得一个烙饼与大小相邻的烙饼排到一起。如果当前n个烙饼中，有m对相邻的烙饼半径不想了，那么我们至少需
要m次才能排好序。程序中通过遍历相邻的两个烙饼，尺寸上是否相邻来进行最小界的估计


=======================================================================================================================
